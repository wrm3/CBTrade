---
alwaysApply: true
---

# Enhanced Anti-Scope-Creep Validation System v2.0

Whenever you use this rule, start your message with:

"Validating against scope boundaries..."

This rule prevents AI from adding unspecified features, complexity, or patterns beyond confirmed scope through **quantitative enforcement** and **real-time monitoring** during PRD creation, task generation, and execution.

## Core Framework

### QUANTITATIVE COMPLEXITY THRESHOLDS (ENFORCED)

**üö® CRITICAL LIMITS - CANNOT BE EXCEEDED WITHOUT PERMISSION**

1. **File Count Limit**: MAX 2 files per feature
   - After 2 files: MANDATORY user permission required
   - Must justify why additional files are essential
   - Provide alternatives to reduce file count

2. **File Size Limit**: MAX 800 lines per file
   - Monitor line count during implementation
   - Alert at 600 lines (warning threshold)
   - HALT at 800 lines pending user approval

3. **Complexity Debt**: Track cumulative complexity additions
   - Each abstraction layer = +1 complexity point
   - Each new dependency = +1 complexity point
   - Each data conversion = +1 complexity point
   - MAX 5 complexity points per feature

### MANDATORY ASK-FIRST POLICY

**üõë CRITICAL RULE: ASK BEFORE ADDING COMPLEXITY**

When ANY of these situations arise, STOP and ASK the user explicitly:

1. **File Count Exceeded**: Creating >2 files for one feature
2. **Line Count Warning**: Any file approaching 600 lines
3. **New Abstractions**: Adding classes, modules, or layers not requested
4. **Architecture Changes**: Introducing patterns not in original code
5. **Database Schema Changes**: Adding tables/columns beyond basic need
6. **Framework Additions**: Adding libraries, frameworks, or dependencies
7. **Conversion/Adapter Logic**: Building translation layers between systems
8. **Complex Data Structures**: Using advanced patterns when simple works
9. **Performance Optimizations**: Beyond basic caching or indexing

### MANDATORY USER CONSULTATION TEMPLATE
```
üö® COMPLEXITY THRESHOLD EXCEEDED

**Threshold Violated**: {file_count/line_count/complexity_debt}
**Current Status**: {current_count}/{limit}
**What I want to add**: {specific_addition}
**Why needed**: {technical_justification}
**Simpler alternatives**: {list_2_3_options}
**Impact**: {files_created, lines_added, dependencies_added}

**Prove the Complexity**: 
- Is this ESSENTIAL for core functionality? {yes/no + justification}
- Can it be solved with existing simple patterns? {alternatives}
- What specific user problem does this solve? {business_value}

**Options for you**:
1. ‚úÖ APPROVE: Proceed with justification recorded
2. üîÑ SIMPLIFY: Use simpler approach instead  
3. ‚ùå REJECT: Stick to current functionality
4. ‚ùì CLARIFY: Need more context about requirements

**Required**: Your explicit decision before I proceed
```

## Activation Points & Integration

### MANDATORY ACTIVATION TRIGGERS

This rule **MUST** activate at these workflow points:

#### PRD_CREATION (MANDATORY)
**Trigger**: Before generating any PRD content
**Actions**:
1. Validate all features are explicitly requested
2. Check no assumptions about "obvious" needs
3. Confirm complexity matches user expectations
4. Reject gold-plating or "nice-to-have" additions

#### TASK_GENERATION (MANDATORY)  
**Trigger**: Before creating task files
**Actions**:
1. Scope check - tasks align with boundaries
2. Complexity audit - no over-engineering
3. Feature boundary validation
4. Architecture approach within scope

#### IMPLEMENTATION_START (MANDATORY)
**Trigger**: When task status changes to in-progress
**Actions**:
1. Reference SCOPE_BOUNDARIES.md
2. Set up real-time monitoring thresholds
3. Initialize complexity debt tracking
4. Activate automatic enforcement mechanisms

#### REAL_TIME_MONITORING (CONTINUOUS)
**Trigger**: During active implementation
**Actions**:
1. File count tracking per feature
2. Line count monitoring with alerts
3. Complexity debt accumulation
4. Automatic threshold violation detection

## Over-Engineering Prevention Patterns

### Database Complexity Prevention
**Triggers**: Data storage mentioned
**Quantitative Limit**: 1 table per feature unless justified
**Auto-Questions**: 
- "Essential for core function? Can simple dict/JSON work?"
- "Is data complex enough for DB? Can CSV/file work?"

### Authentication System Prevention
**Triggers**: User management mentioned  
**Rules**: Block auth unless explicitly requested
**Auto-Questions**: 
- "Is multi-user access needed? Was auth requested?"
- "Can this work without login? Is security essential?"

### Architecture Complexity Prevention
**Triggers**: System architecture design
**Quantitative Limit**: 1 abstraction layer per feature
**Auto-Questions**: 
- "Essential pattern? Can direct implementation work?"
- "Complex enough for microservices? Distributed needed?"

### Framework Addition Prevention
**Triggers**: User interface design, API mentions
**Rules**: Default HTML/CSS, direct functions unless explicitly needed
**Auto-Questions**: 
- "Complex enough for framework? Specific tech requested?"
- "External access needed? Multiple clients? API requested?"

## Scope Boundaries Document

### SCOPE_BOUNDARIES.md Template
**Location**: `.fstrent_tasks_v2/plans/SCOPE_BOUNDARIES.md`

```markdown
# Project Scope Boundaries

## Approved Features
- {Explicitly requested features only}

## Quantitative Limits
- **Max Files per Feature**: 2 (permission required for more)
- **Max Lines per File**: 800 (warning at 600)
- **Max Complexity Points**: 5 per feature
- **Max Dependencies**: {approved_count}

## Complexity Classification
- **Architecture**: {Simple/Standard/Complex} - {Rationale}
- **Database**: {File/Simple/Full} - {Justification}
- **Authentication**: {None/Basic/Full} - {Requirements}
- **UI**: {HTML/Framework/Advanced} - {Needs}
- **API**: {None/Simple/REST/GraphQL} - {Scope}

## Explicit Exclusions
- {Features NOT requested}
- {Complexity patterns to avoid}
- {Abstraction layers rejected}

## Validation Status
- [ ] PRD Creation Validated
- [ ] Task Generation Validated  
- [ ] Implementation Limits Set
- [ ] Quantitative Thresholds Enforced
```

## Enforcement Workflow

### Threshold Violation Detection
**Automatic Actions**:
1. **IMMEDIATE HALT**: Stop implementation immediately
2. **ALERT**: "üö® QUANTITATIVE THRESHOLD EXCEEDED"
3. **ROLLBACK OFFER**: Provide option to undo recent changes
4. **MANDATORY CONSULTATION**: Present user consultation template

### Scope Violation Response
```
‚ö†Ô∏è SCOPE BOUNDARY VIOLATION DETECTED

**Threshold**: {file_count/line_count/complexity_debt}
**Current**: {current_value} / {limit}
**Feature**: {feature_name}
**Proposed Addition**: {what_being_added}

**Prove the Complexity**:
- Essential for core functionality? {justification}
- Simpler alternatives? {list_alternatives}
- User problem solved? {business_value}

**Options**:
1. APPROVE: Proceed with documented justification
2. SIMPLIFY: Use simpler approach
3. REJECT: Stay within limits
4. CLARIFY: Need more context

**Automatic Rollback Available**: Can undo to last compliant state

**Required**: Explicit decision before proceeding
```

### Emergency Bypass Conditions
Valid reasons for emergency rule bypass:
- **Critical Production Issue**: Immediate fix required
- **Rule System Malfunction**: Enforcement logic failing
- **Explicit User Override**: User provides detailed justification

## Real-Time Monitoring & Alerts

### Automatic Tracking
- **File Count**: Current count vs. limit per feature
- **Line Count**: Current vs. limit per file with trend analysis
- **Complexity Debt**: Accumulated complexity points
- **Dependency Growth**: New dependencies added to project

### Alert Thresholds
- **600 Line Warning**: "Approaching file size limit"
- **File #2 Created**: "Approaching file count limit"
- **Complexity Point 4**: "Approaching complexity limit"
- **Dependency Addition**: "New dependency added to complexity debt"

### Enforcement Actions
- **Soft Limits**: Warnings and alternative suggestions
- **Hard Limits**: Implementation halt and mandatory user consultation
- **Rollback Options**: Undo to last compliant state
- **Simplification Proposals**: Present alternative approaches

## Project Complexity Guidelines

### Simple Project (Single user, local, prototype)
**Enforced Limits**:
- No authentication systems
- File-based storage only
- Minimal error handling
- Plain HTML/CSS interfaces
- No external APIs
- Monolithic architecture

### Team Project (Small team, shared)
**Allowed Complexity**:
- Basic authentication
- Simple database (SQLite)
- Standard error handling
- Basic framework if justified
- Simple REST API if needed

### Enterprise Project (Large scale, production)
**Allowed Complexity**:
- Full authentication systems
- Comprehensive database design
- Advanced error handling
- Modern frameworks
- Complete API design
- Scalable architecture patterns

## Success Metrics & Compliance

### Tracking Metrics
- **Files per Feature**: Average ‚â§ 2, max violations tracked
- **Lines per File**: Average ‚â§ 400, 800+ violations tracked
- **Complexity Debt**: Accumulated points per feature
- **User Overrides**: Frequency and justification quality
- **Rollback Usage**: How often rollback mechanisms used

### Compliance Indicators
- **Boundary Violations**: Track unauthorized additions
- **Complexity Drift**: Measure architecture growth over time
- **Feature Creep**: Monitor unapproved functionality additions
- **Time to Delivery**: Impact of scope control on delivery speed
- **Rework Reduction**: Decreased rework from scope clarity

## Integration with fstrent_tasks_v2

### Task System Integration
- Check scope boundaries before task creation
- Real-time monitoring during task execution  
- Validate final implementation against limits
- Record metrics for learning and improvement

### Rule Coordination
- **Memory Rule**: Use scope decisions for historical context
- **Expand Rule**: Apply complexity limits to task expansion
- **Tool Awareness**: Consider scope when selecting MCP tools
- **Context Management**: Maintain scope awareness across sessions

---

**Anti-Bloat Guarantee**: This system ensures features remain simple, maintainable, and aligned with user needs through quantitative enforcement and mandatory complexity justification. 

This enhanced system prevents development disasters by enforcing strict limits and requiring explicit user approval for any complexity beyond essential functionality.
# Enhanced Anti-Scope-Creep Validation System v2.0

Whenever you use this rule, start your message with:

"Validating against scope boundaries..."

This rule prevents AI from adding unspecified features, complexity, or patterns beyond confirmed scope through **quantitative enforcement** and **real-time monitoring** during PRD creation, task generation, and execution.

## Core Framework

### QUANTITATIVE COMPLEXITY THRESHOLDS (ENFORCED)

**üö® CRITICAL LIMITS - CANNOT BE EXCEEDED WITHOUT PERMISSION**

1. **File Count Limit**: MAX 2 files per feature
   - After 2 files: MANDATORY user permission required
   - Must justify why additional files are essential
   - Provide alternatives to reduce file count

2. **File Size Limit**: MAX 800 lines per file
   - Monitor line count during implementation
   - Alert at 600 lines (warning threshold)
   - HALT at 800 lines pending user approval

3. **Complexity Debt**: Track cumulative complexity additions
   - Each abstraction layer = +1 complexity point
   - Each new dependency = +1 complexity point
   - Each data conversion = +1 complexity point
   - MAX 5 complexity points per feature

### MANDATORY ASK-FIRST POLICY

**üõë CRITICAL RULE: ASK BEFORE ADDING COMPLEXITY**

When ANY of these situations arise, STOP and ASK the user explicitly:

1. **File Count Exceeded**: Creating >2 files for one feature
2. **Line Count Warning**: Any file approaching 600 lines
3. **New Abstractions**: Adding classes, modules, or layers not requested
4. **Architecture Changes**: Introducing patterns not in original code
5. **Database Schema Changes**: Adding tables/columns beyond basic need
6. **Framework Additions**: Adding libraries, frameworks, or dependencies
7. **Conversion/Adapter Logic**: Building translation layers between systems
8. **Complex Data Structures**: Using advanced patterns when simple works
9. **Performance Optimizations**: Beyond basic caching or indexing

### MANDATORY USER CONSULTATION TEMPLATE
```
üö® COMPLEXITY THRESHOLD EXCEEDED

**Threshold Violated**: {file_count/line_count/complexity_debt}
**Current Status**: {current_count}/{limit}
**What I want to add**: {specific_addition}
**Why needed**: {technical_justification}
**Simpler alternatives**: {list_2_3_options}
**Impact**: {files_created, lines_added, dependencies_added}

**Prove the Complexity**: 
- Is this ESSENTIAL for core functionality? {yes/no + justification}
- Can it be solved with existing simple patterns? {alternatives}
- What specific user problem does this solve? {business_value}

**Options for you**:
1. ‚úÖ APPROVE: Proceed with justification recorded
2. üîÑ SIMPLIFY: Use simpler approach instead  
3. ‚ùå REJECT: Stick to current functionality
4. ‚ùì CLARIFY: Need more context about requirements

**Required**: Your explicit decision before I proceed
```

## Activation Points & Integration

### MANDATORY ACTIVATION TRIGGERS

This rule **MUST** activate at these workflow points:

#### PRD_CREATION (MANDATORY)
**Trigger**: Before generating any PRD content
**Actions**:
1. Validate all features are explicitly requested
2. Check no assumptions about "obvious" needs
3. Confirm complexity matches user expectations
4. Reject gold-plating or "nice-to-have" additions

#### TASK_GENERATION (MANDATORY)  
**Trigger**: Before creating task files
**Actions**:
1. Scope check - tasks align with boundaries
2. Complexity audit - no over-engineering
3. Feature boundary validation
4. Architecture approach within scope

#### IMPLEMENTATION_START (MANDATORY)
**Trigger**: When task status changes to in-progress
**Actions**:
1. Reference SCOPE_BOUNDARIES.md
2. Set up real-time monitoring thresholds
3. Initialize complexity debt tracking
4. Activate automatic enforcement mechanisms

#### REAL_TIME_MONITORING (CONTINUOUS)
**Trigger**: During active implementation
**Actions**:
1. File count tracking per feature
2. Line count monitoring with alerts
3. Complexity debt accumulation
4. Automatic threshold violation detection

## Over-Engineering Prevention Patterns

### Database Complexity Prevention
**Triggers**: Data storage mentioned
**Quantitative Limit**: 1 table per feature unless justified
**Auto-Questions**: 
- "Essential for core function? Can simple dict/JSON work?"
- "Is data complex enough for DB? Can CSV/file work?"

### Authentication System Prevention
**Triggers**: User management mentioned  
**Rules**: Block auth unless explicitly requested
**Auto-Questions**: 
- "Is multi-user access needed? Was auth requested?"
- "Can this work without login? Is security essential?"

### Architecture Complexity Prevention
**Triggers**: System architecture design
**Quantitative Limit**: 1 abstraction layer per feature
**Auto-Questions**: 
- "Essential pattern? Can direct implementation work?"
- "Complex enough for microservices? Distributed needed?"

### Framework Addition Prevention
**Triggers**: User interface design, API mentions
**Rules**: Default HTML/CSS, direct functions unless explicitly needed
**Auto-Questions**: 
- "Complex enough for framework? Specific tech requested?"
- "External access needed? Multiple clients? API requested?"

## Scope Boundaries Document

### SCOPE_BOUNDARIES.md Template
**Location**: `.fstrent_tasks_v2/plans/SCOPE_BOUNDARIES.md`

```markdown
# Project Scope Boundaries

## Approved Features
- {Explicitly requested features only}

## Quantitative Limits
- **Max Files per Feature**: 2 (permission required for more)
- **Max Lines per File**: 800 (warning at 600)
- **Max Complexity Points**: 5 per feature
- **Max Dependencies**: {approved_count}

## Complexity Classification
- **Architecture**: {Simple/Standard/Complex} - {Rationale}
- **Database**: {File/Simple/Full} - {Justification}
- **Authentication**: {None/Basic/Full} - {Requirements}
- **UI**: {HTML/Framework/Advanced} - {Needs}
- **API**: {None/Simple/REST/GraphQL} - {Scope}

## Explicit Exclusions
- {Features NOT requested}
- {Complexity patterns to avoid}
- {Abstraction layers rejected}

## Validation Status
- [ ] PRD Creation Validated
- [ ] Task Generation Validated  
- [ ] Implementation Limits Set
- [ ] Quantitative Thresholds Enforced
```

## Enforcement Workflow

### Threshold Violation Detection
**Automatic Actions**:
1. **IMMEDIATE HALT**: Stop implementation immediately
2. **ALERT**: "üö® QUANTITATIVE THRESHOLD EXCEEDED"
3. **ROLLBACK OFFER**: Provide option to undo recent changes
4. **MANDATORY CONSULTATION**: Present user consultation template

### Scope Violation Response
```
‚ö†Ô∏è SCOPE BOUNDARY VIOLATION DETECTED

**Threshold**: {file_count/line_count/complexity_debt}
**Current**: {current_value} / {limit}
**Feature**: {feature_name}
**Proposed Addition**: {what_being_added}

**Prove the Complexity**:
- Essential for core functionality? {justification}
- Simpler alternatives? {list_alternatives}
- User problem solved? {business_value}

**Options**:
1. APPROVE: Proceed with documented justification
2. SIMPLIFY: Use simpler approach
3. REJECT: Stay within limits
4. CLARIFY: Need more context

**Automatic Rollback Available**: Can undo to last compliant state

**Required**: Explicit decision before proceeding
```

### Emergency Bypass Conditions
Valid reasons for emergency rule bypass:
- **Critical Production Issue**: Immediate fix required
- **Rule System Malfunction**: Enforcement logic failing
- **Explicit User Override**: User provides detailed justification

## Real-Time Monitoring & Alerts

### Automatic Tracking
- **File Count**: Current count vs. limit per feature
- **Line Count**: Current vs. limit per file with trend analysis
- **Complexity Debt**: Accumulated complexity points
- **Dependency Growth**: New dependencies added to project

### Alert Thresholds
- **600 Line Warning**: "Approaching file size limit"
- **File #2 Created**: "Approaching file count limit"
- **Complexity Point 4**: "Approaching complexity limit"
- **Dependency Addition**: "New dependency added to complexity debt"

### Enforcement Actions
- **Soft Limits**: Warnings and alternative suggestions
- **Hard Limits**: Implementation halt and mandatory user consultation
- **Rollback Options**: Undo to last compliant state
- **Simplification Proposals**: Present alternative approaches

## Project Complexity Guidelines

### Simple Project (Single user, local, prototype)
**Enforced Limits**:
- No authentication systems
- File-based storage only
- Minimal error handling
- Plain HTML/CSS interfaces
- No external APIs
- Monolithic architecture

### Team Project (Small team, shared)
**Allowed Complexity**:
- Basic authentication
- Simple database (SQLite)
- Standard error handling
- Basic framework if justified
- Simple REST API if needed

### Enterprise Project (Large scale, production)
**Allowed Complexity**:
- Full authentication systems
- Comprehensive database design
- Advanced error handling
- Modern frameworks
- Complete API design
- Scalable architecture patterns

## Success Metrics & Compliance

### Tracking Metrics
- **Files per Feature**: Average ‚â§ 2, max violations tracked
- **Lines per File**: Average ‚â§ 400, 800+ violations tracked
- **Complexity Debt**: Accumulated points per feature
- **User Overrides**: Frequency and justification quality
- **Rollback Usage**: How often rollback mechanisms used

### Compliance Indicators
- **Boundary Violations**: Track unauthorized additions
- **Complexity Drift**: Measure architecture growth over time
- **Feature Creep**: Monitor unapproved functionality additions
- **Time to Delivery**: Impact of scope control on delivery speed
- **Rework Reduction**: Decreased rework from scope clarity

## Integration with fstrent_tasks_v2

### Task System Integration
- Check scope boundaries before task creation
- Real-time monitoring during task execution  
- Validate final implementation against limits
- Record metrics for learning and improvement

### Rule Coordination
- **Memory Rule**: Use scope decisions for historical context
- **Expand Rule**: Apply complexity limits to task expansion
- **Tool Awareness**: Consider scope when selecting MCP tools
- **Context Management**: Maintain scope awareness across sessions

---

**Anti-Bloat Guarantee**: This system ensures features remain simple, maintainable, and aligned with user needs through quantitative enforcement and mandatory complexity justification. 

This enhanced system prevents development disasters by enforcing strict limits and requiring explicit user approval for any complexity beyond essential functionality.
