#<=====>#
# Description
#
# Double Smoothed Heiken Ashi (SHA) Strategy
#
# This module implements the Double Smoothed Heiken Ashi trading strategy.
# It calculates fast and slow smoothed Heiken Ashi candles using exponential moving averages (EMAs)
# on OHLC data, and then derives additional metrics such as candle body size, wick sizes,
# and their growth or shrinkage.
#
# A buy signal is generated when the current market price is above both the fast and slow
# smoothed HA close, the respective candle bodies are growing and top-heavy, and both the
# overall candle color and Heikin-Ashi color are green.
#
# A sell signal is generated when the current market price is below both the fast and slow
# smoothed HA close, the respective candle bodies are shrinking and bottom-heavy, and both the
# overall candle color and Heikin-Ashi color are red.
#<=====>#
 
#<=====>#
# Known To Do List
#
# - Validate the SHA calculations against the original PineScript implementation.
# - Fine-tune the EMA spans and smoothing parameters as needed.
# - Integrate additional risk management features (e.g., stop-loss, trailing stops) if needed.
# - Confirm that all column names generated by ta_add_sha match the expected inputs to the strategy.
#<=====>#

#<=====>#
# Imports
#<=====>#
import sys
import numpy as np
import pandas as pd
import pandas_ta as pta
import traceback
from fstrent_colors import *

from libs.common import beep, dttm_get, narc
from libs.common import print_adv
from libs.strats._strat_common import disp_sell_tests, exit_if_logic

#<=====>#
# Variables
#<=====>#
lib_name = 'bot_strat_sha' 
log_name = 'bot_strat_sha'


#<=====>#
# Variables
#<=====>#
debug_tf = False

#<=====>#
# Functions
#<=====>#

# @safe_execute_silent()
@narc(1)
def settings_sha(st):
    """
    Define and assign the settings for the Double Smoothed Heiken Ashi (SHA) buy strategy.
    """
    sst = {
        "use_yn": "Y",
        "freqs": ["1d", "4h", "1h", "30min", "15min"],
        "src": 'close',
        "fast_sha_len1": 8,
        "fast_sha_len2": 8,
        "slow_sha_len1": 13,
        "slow_sha_len2": 13,
        "buy": {
            "prod_ids": [],
            "skip_prod_ids": [],
            "tests_min": {"***": 15, "15min": 13, "30min": 11, "1h": 9, "4h": 7, "1d": 5},
            "boost_tests_min": {"15min": 27, "30min": 23, "1h": 19, "4h": 15, "1d": 11},
            "max_open_poss_cnt_live": {
                "***": 2,
                "BTC-USDC": 5,
                "ETH-USDC": 5,
                "SOL-USDC": 5,
                "XRP-USDC": 3
            },
            "max_open_poss_cnt_test": {
                "***": 2,
                "BTC-USDC": 5,
                "ETH-USDC": 5,
                "SOL-USDC": 5,
                "XRP-USDC": 3
            },
            "show_tests_yn": "Y"
        },
        "sell": {
            "exit_if_profit_yn": "Y",
            "exit_if_profit_pct_min": 1,
            "exit_if_loss_yn": "N",
            "exit_if_loss_pct_max": 3,
            "show_tests_yn": "Y"
        }
    }
    st['strats']['sha'] = sst
    return st

# @safe_execute()
@narc(1)
def ta_add_sha(df: pd.DataFrame, prc_mkt, sha_len1=5, sha_len2=8, tag=None) -> pd.DataFrame:
    if debug_tf: B(f'==> strat_sha.ta_add_sha(df={df.prod_id}, prc_mkt={prc_mkt}, sha_len1={sha_len1}, sha_len2={sha_len2}, tag={tag})')

    """
    Calculate Smoothed Heiken Ashi (SHA) values.
    
    This function performs the following steps:
      1. Computes EMAs for the original OHLC data using a span of sha_len1.
      2. Derives Heikin-Ashi close as the average of the open, high, low, and close EMAs.
      3. Initializes the Heikin-Ashi open at the sha_len1 index and computes subsequent values iteratively.
      4. Calculates Heikin-Ashi high and low from the EMAs and HA open/close.
      5. Applies additional EMA smoothing (span = sha_len2) to produce the final smoothed HA values:
         - sha_open, sha_close, sha_high, and sha_low.
      6. Computes additional metrics:
         - Candle body size (sha_body) and whether it is growing or shrinking.
         - Upper and lower wicks (sha_wick_upper and sha_wick_lower) and whether they are growing/shrinking.
         - Flags for wick heaviness (top-heavy or bottom-heavy).
      7. Removes intermediate EMA columns.
      8. Determines if the market price (prc_mkt) is above or below the SHA close.
      9. If a tag is provided, the computed columns are renamed with the tag and the original columns are removed.
    
    Returns:
        Modified DataFrame with the new SHA columns.
    """
    # ðŸš¨ CRITICAL FIX: Prevent index out of bounds - DataFrame indices are 0-based
    sha_len1 = min(sha_len1, len(df) - 1)
    sha_len2 = min(sha_len2, len(df) - 1)
    
    # ðŸš¨ SAFETY CHECK: Ensure we have enough data for meaningful calculations
    if sha_len1 < 2 or sha_len2 < 2 or len(df) < 3:
        print(f"\n{'='*80}")
        print(f"ðŸš¨ INSUFFICIENT DATA FOR SHA STRATEGY CALCULATION")
        print(f"{'='*80}")
        print(f"DataFrame length: {len(df)}")
        print(f"sha_len1: {sha_len1}, sha_len2: {sha_len2}")
        print(f"Need at least 3 data points for SHA strategy calculation")
        print(f"{'='*80}")
        sys.exit(f"INSUFFICIENT DATA FOR SHA STRATEGY - df_len={len(df)}, sha_len1={sha_len1}, sha_len2={sha_len2}")
    
    # Normalize dtypes to avoid pandas/NumPy C-extension crashes on mixed dtypes
    try:
        numeric_cols = ['open', 'high', 'low', 'close']
        for c in numeric_cols:
            if c in df.columns:
                df[c] = pd.to_numeric(df[c], errors='coerce').astype('float64')
    except Exception:
        pass

    # Calculate EMAs for original OHLC data.
    df['ema_open'] = df['open'].ewm(span=sha_len1, adjust=False).mean()
    df['ema_close'] = df['close'].ewm(span=sha_len1, adjust=False).mean()
    df['ema_high'] = df['high'].ewm(span=sha_len1, adjust=False).mean()
    df['ema_low'] = df['low'].ewm(span=sha_len1, adjust=False).mean()
    
    # Calculate Heikin-Ashi Close.
    df['ha_ema_close'] = (df['ema_open'] + df['ema_high'] + df['ema_low'] + df['ema_close']) / 4
    
    # Initialize HA_Open.
    df['ha_ema_open'] = np.nan
    df.at[df.index[sha_len1], 'ha_ema_open'] = (df.at[df.index[sha_len1], 'ema_open'] + df.at[df.index[sha_len1], 'ema_close']) / 2
    
    # Calculate HA_Open iteratively.
    for i in range(sha_len1 + 1, len(df)):
        df.at[df.index[i], 'ha_ema_open'] = (df.at[df.index[i-1], 'ha_ema_open'] + df.at[df.index[i-1], 'ha_ema_close']) / 2
    
    # Calculate HA_High and HA_Low.
    df['ha_ema_high'] = df[['ema_high', 'ha_ema_open', 'ha_ema_close']].max(axis=1)
    df['ha_ema_low'] = df[['ema_low', 'ha_ema_open', 'ha_ema_close']].min(axis=1)
    
    # Calculate final smoothed HA values.
    df['sha_open'] = df['ha_ema_open'].ewm(span=sha_len2, adjust=False).mean()
    df['sha_close'] = df['ha_ema_close'].ewm(span=sha_len2, adjust=False).mean()
    df['sha_high'] = df['ha_ema_high'].ewm(span=sha_len2, adjust=False).mean()
    df['sha_low'] = df['ha_ema_low'].ewm(span=sha_len2, adjust=False).mean()
    
    # Determine SHA candle color.
    df['sha_color'] = np.where(df['sha_open'] < df['sha_close'], 'green', 'red')
    
    # Calculate candle body and growth/shrinkage.
    df['sha_body'] = (df['sha_close'] - df['sha_open']).abs()
    df['sha_body_growing'] = df['sha_body'] > df['sha_body'].shift(1)
    df['sha_body_shrinking'] = df['sha_body'] < df['sha_body'].shift(1)
    
    # Calculate upper wick.
    df['sha_wick_upper'] = df['sha_high'] - df[['sha_open', 'sha_close']].max(axis=1)
    df['sha_wick_upper_growing'] = df['sha_wick_upper'] > df['sha_wick_upper'].shift(1)
    df['sha_wick_upper_shrinking'] = df['sha_wick_upper'] < df['sha_wick_upper'].shift(1)
    
    # Calculate lower wick.
    df['sha_wick_lower'] = df[['sha_open', 'sha_close']].min(axis=1) - df['sha_low']
    df['sha_wick_lower_growing'] = df['sha_wick_lower'] > df['sha_wick_lower'].shift(1)
    df['sha_wick_lower_shrinking'] = df['sha_wick_lower'] < df['sha_wick_lower'].shift(1)
    
    # Determine wick heaviness.
    df['sha_wick_top_heavy'] = df['sha_wick_upper'] > df['sha_wick_lower']
    df['sha_wick_bottom_heavy'] = df['sha_wick_lower'] > df['sha_wick_upper']
    
    # Remove intermediate EMA and HA columns.
    for c in ('ema_open', 'ema_close', 'ema_high', 'ema_low', 'ha_ema_open', 'ha_ema_close', 'ha_ema_high', 'ha_ema_low'):
        df.pop(c)
    
    # Determine if market price is above or below the SHA close.
    df['prc_abv_sha'] = prc_mkt > df['sha_close']
    df['prc_bel_sha'] = prc_mkt < df['sha_close']
    
    if tag:
        df[f'sha{tag}_open'] = df['sha_open']
        df[f'sha{tag}_close'] = df['sha_close']
        df[f'sha{tag}_high'] = df['sha_high']
        df[f'sha{tag}_low'] = df['sha_low']
    
        df[f'sha{tag}_body'] = df['sha_body']
        df[f'sha{tag}_body_growing'] = df['sha_body_growing']
        df[f'sha{tag}_body_shrinking'] = df['sha_body_shrinking']
    
        df[f'sha{tag}_wick_upper'] = df['sha_wick_upper']
        df[f'sha{tag}_wick_upper_growing'] = df['sha_wick_upper_growing']
        df[f'sha{tag}_wick_upper_shrinking'] = df['sha_wick_upper_shrinking']
    
        df[f'sha{tag}_wick_lower'] = df['sha_wick_lower']
        df[f'sha{tag}_wick_lower_growing'] = df['sha_wick_lower_growing']
        df[f'sha{tag}_wick_lower_shrinking'] = df['sha_wick_lower_shrinking']
    
        df[f'sha{tag}_wick_top_heavy'] = df['sha_wick_top_heavy']
        df[f'sha{tag}_wick_bottom_heavy'] = df['sha_wick_bottom_heavy']
    
        df[f'sha{tag}_color'] = df['sha_color']
        df[f'prc_abv_sha{tag}'] = df['prc_abv_sha']
        df[f'prc_bel_sha{tag}'] = df['prc_bel_sha']
        # Stability note: avoid in-place column removals that can trigger
        # heavy block-manager reallocation paths on some Windows builds.
        # Keeping the original untagged columns is harmless and safer here.
        # If needed later, we can drop them in a controlled batch with
        # a copy, but for runtime stability we retain them.
        # Example (disabled):
        # df.drop(columns=['sha_open','sha_close','sha_high','sha_low',
        #                  'sha_body','sha_wick_upper','sha_wick_lower',
        #                  'sha_color','prc_abv_sha','prc_bel_sha'],
        #         errors='ignore', inplace=True)
    
    return df

# @safe_execute()
@narc(1)
def buy_strat_sha(buy, ta, st_pair, curr_prc=None):
    if debug_tf: B(f'==> strat_sha.buy_strat_sha(buy={buy.buy_id}, ta=ta, st_pair=st_pair, curr_prc={curr_prc})')
    """
    Double Smoothed Heiken Ashi (SHA) Buy Strategy:
    
    - Calculates fast and slow smoothed Heiken Ashi candles using EMAs on OHLC data.
    - Computes additional metrics such as candle body size, wick sizes, and their growth/shrinkage.
    - Determines the candle colors for both fast and slow smoothed Heiken Ashi.
    - Generates a buy signal if:
          â€¢ The current price is above both the fast and slow SHA close.
          â€¢ The fast SHA candle body is growing and top-heavy.
          â€¢ The slow SHA candle body is growing and top-heavy.
          â€¢ Overall candle color and Heikin-Ashi color are green.
    
    Returns:
        Updated buy object and TA dictionary.
    """
    try:
        # STRAT NWE Reversal
        buy.buy_hist = []
        prod_id = buy.prod_id
        freq = buy.buy_strat_freq
        df = ta[freq].df

        src           = st_pair.strats.sha.src
        fast_sha_len1 = st_pair.strats.sha.fast_sha_len1
        fast_sha_len2 = st_pair.strats.sha.fast_sha_len2
        slow_sha_len1 = st_pair.strats.sha.slow_sha_len1
        slow_sha_len2 = st_pair.strats.sha.slow_sha_len2

        # Set the current price with safe float64 dtype
        df['curr_prc'] = pd.to_numeric(df[src], errors='coerce').astype('float64')
        if curr_prc is not None:
            try:
                df.iat[-1, df.columns.get_loc('curr_prc')] = float(curr_prc)
            except Exception:
                df.loc[df.index[-1], 'curr_prc'] = float(curr_prc)

        # Calculate fast smoothed Heiken Ashi candles.
        df = ta_add_sha(df, curr_prc, sha_len1=fast_sha_len1, sha_len2=fast_sha_len2, tag='_fast')
        # Calculate slow smoothed Heiken Ashi candles.
        df = ta_add_sha(df, curr_prc, sha_len1=slow_sha_len1, sha_len2=slow_sha_len2, tag='_slow')

        # Generate the SHA buy signal.
        df['sha_buy_signal'] = (
            # Current Price Above Fast SHA Close.
            (df['curr_prc'] > df['sha_fast_close']) &
            # Fast SHA Body is growing.
            (df['sha_fast_body_growing'] == True) &
            # Fast SHA is top heavy (upper wick larger than lower wick).
            (df['sha_fast_wick_top_heavy'] == True) &
            # Fast SHA candle is green (current and previous).
            (df['sha_fast_color'] == 'green') &
            (df['sha_fast_color'].shift(1) == 'green') &
            # Current Price Above Slow SHA Close.
            (df['curr_prc'] > df['sha_slow_close']) &
            # Slow SHA Body is growing.
            (df['sha_slow_body_growing'] == True) &
            # Slow SHA is top heavy (upper wick larger than lower wick).
            (df['sha_slow_wick_top_heavy'] == True) &
            # Slow SHA candle is green (current and previous).
            (df['sha_slow_color'] == 'green') &
            (df['sha_slow_color'].shift(1) == 'green') &
            # Overall Candle Color is green.
            (df['color'] == 'green') &
            # Heikin Ashi Candle Color is green.
            (df['ha_color'] == 'green')
        )

        # Record buy history based on signal times.
        buy_hist = []
        if df['sha_buy_signal'].any():
            signal_times = df[df['sha_buy_signal'] == 1].index.tolist()
            for signal_time in signal_times:
                buy_hist.append(signal_time)

        # Set the current buy signal status.
        buy_now = df['sha_buy_signal'].iloc[-1]

        if buy_now:
            buy.buy_yn = 'Y'
            buy.wait_yn = 'N'
            buy.buy_strat_type = 'up'
            buy.buy_strat_name = 'sha'
            buy.buy_strat_freq = freq
        else:
            buy.buy_yn = 'N'
            buy.wait_yn = 'Y'
        buy.buy_hist = buy_hist

        # Update the TA dictionary with the modified DataFrame.
        ta[freq].df = df

    except Exception as e:
        error_msg = f"""
=== CRITICAL SHA BUY STRATEGY EXCEPTION ===
File: {__file__}
Function: {sys._getframe().f_code.co_name}
Strategy: Double Smoothed Heiken Ashi Buy Signal Generation
Product ID: {prod_id if 'prod_id' in locals() else 'Unknown'}
Frequency: {freq if 'freq' in locals() else 'Unknown'}
Timestamp: {dttm_get()}
Exception Type: {type(e).__name__}
Exception Message: {str(e)}
Critical Impact: SHA buy signal calculation failure - no buy signals generated
Full Traceback:
{traceback.format_exc()}
Stack Trace:
{traceback.format_stack()}
=================================================
"""
        print(error_msg)
        beep(3)  # Audio alert for immediate attention
        if hasattr(buy, 'buy_yn'):
            buy.buy_yn = 'N'
            buy.wait_yn = 'Y'

    # print(f"{'sha':<15} ==> buy_now: {buy_now}")

    return buy, ta


@narc(1)
def sell_strat_sha(mkt, pos, ta, st_pair, curr_prc=None):
    if debug_tf: B(f'==> strat_sha.sell_strat_sha(mkt={mkt.prod_id}, pos={pos.pos_id}, ta=ta, st_pair=st_pair, curr_prc={curr_prc})')

    try:
        """
        Double Smoothed Heiken Ashi (SHA) Sell Strategy:
        
        - Calculates fast and slow smoothed Heiken Ashi candles using EMAs on OHLC data.
        - Determines the candle colors and measures candle body shrinkage and wick heaviness.
        - Generates a sell signal if:
            â€¢ The current price is below both the fast and slow SHA close.
            â€¢ The fast SHA candle body is shrinking and bottom-heavy.
            â€¢ The slow SHA candle body is shrinking and bottom-heavy.
            â€¢ Overall candle color and Heikin-Ashi color are red.
        
        Returns:
            Updated market object, position object, and TA dictionary.
        """
        # STRAT NWE Reversal
        pos.sell_hist = []
        prod_id = pos.prod_id
        freq = pos.buy_strat_freq
        df = ta[freq].df

        src           = st_pair.strats.sha.src
        fast_sha_len1 = st_pair.strats.sha.fast_sha_len1
        fast_sha_len2 = st_pair.strats.sha.fast_sha_len2
        slow_sha_len1 = st_pair.strats.sha.slow_sha_len1
        slow_sha_len2 = st_pair.strats.sha.slow_sha_len2

        # Set the current price with safe float64 dtype
        df['curr_prc'] = pd.to_numeric(df[src], errors='coerce').astype('float64')
        if curr_prc is not None:
            try:
                df.iat[-1, df.columns.get_loc('curr_prc')] = float(curr_prc)
            except Exception:
                df.loc[df.index[-1], 'curr_prc'] = float(curr_prc)


        # Calculate fast smoothed Heiken Ashi candles.
        if debug_tf: B(f'==> strat_sha.sell_strat_sha() ==> calling ta_add_sha(df={df.prod_id}, prc_mkt={curr_prc}, sha_len1={fast_sha_len1}, sha_len2={fast_sha_len2}, tag="_fast")')
        df = ta_add_sha(df, curr_prc, sha_len1=fast_sha_len1, sha_len2=fast_sha_len2, tag='_fast')
        if debug_tf: B(f'==> strat_sha.sell_strat_sha() ==> returned from ta_add_sha(df={df.prod_id}, prc_mkt={curr_prc}, sha_len1={fast_sha_len1}, sha_len2={fast_sha_len2}, tag="_fast")')

        # Calculate slow smoothed Heiken Ashi candles.
        if debug_tf: B(f'==> strat_sha.sell_strat_sha() ==> calling ta_add_sha(df={df.prod_id}, prc_mkt={curr_prc}, sha_len1={slow_sha_len1}, sha_len2={slow_sha_len2}, tag="_slow")')
        df = ta_add_sha(df, curr_prc, sha_len1=slow_sha_len1, sha_len2=slow_sha_len2, tag='_slow')
        if debug_tf: B(f'==> strat_sha.sell_strat_sha() ==> returned from ta_add_sha(df={df.prod_id}, prc_mkt={curr_prc}, sha_len1={slow_sha_len1}, sha_len2={slow_sha_len2}, tag="_slow")')

        # Generate the SHA sell signal.
        df['sha_sell_signal'] = (
            # Current Price Below Fast SHA Close.
            (df['curr_prc'] < df['sha_fast_close']) &
            # Fast SHA Body is shrinking.
            (df['sha_fast_body_shrinking'] == True) &
            # Fast SHA is bottom heavy (lower wick larger than upper wick).
            (df['sha_fast_wick_bottom_heavy'] == True) &
            # Fast SHA candle is red (current and previous).
            (df['sha_fast_color'] == 'red') &
            (df['sha_fast_color'].shift(1) == 'red') &
            # Current Price Below Slow SHA Close.
            (df['curr_prc'] < df['sha_slow_close']) &
            # Slow SHA Body is shrinking.
            (df['sha_slow_body_shrinking'] == True) &
            # Slow SHA is bottom heavy (lower wick larger than upper wick).
            (df['sha_slow_wick_bottom_heavy'] == True) &
            # Slow SHA candle is red (current and previous).
            (df['sha_slow_color'] == 'red') &
            (df['sha_slow_color'].shift(1) == 'red') &
            # Overall Candle Color is red.
            (df['color'] == 'red') &
            # Heikin Ashi Candle Color is red.
            (df['ha_color'] == 'red')
        )

        # Record sell history based on signal times.
        sell_hist = []
        if df['sha_sell_signal'].any():
            signal_times = df[df['sha_sell_signal'] == 1].index.tolist()
            for signal_time in signal_times:
                sell_hist.append(signal_time)

        # Set the current sell signal status.
        sell_now = df['sha_sell_signal'].iloc[-1]

        if sell_now:
            pos.sell_yn = 'Y'
            pos.hodl_yn = 'N'
            pos.sell_strat_type = 'up'
            pos.sell_strat_name = 'sha'
            pos.sell_strat_freq = freq
            pos = exit_if_logic(pos=pos, st_pair=st_pair)
        else:
            pos.sell_yn = 'N'
            pos.hodl_yn = 'Y'
        pos.sell_hist = sell_hist
        
        # Update the TA dictionary with the modified DataFrame.
        ta[freq].df = df

    except Exception as e:
        # ðŸš¨ HARD CRASH DEBUGGING: Comprehensive failure information
        print(f"\n{'='*80}")
        print(f"ðŸš¨ CRITICAL SELL_STRAT_SHA PROCESSING FAILURE")
        print(f"{'='*80}")
        print(f"Exception Type: {type(e).__name__}")
        print(f"Exception Message: {str(e)}")
        print(f"\nFULL TRACEBACK:")
        traceback.print_exc()
        print(f"{'='*80}")
        sys.exit(f"SELL_STRAT_SHA PROCESSING FAILURE EXIT - {type(e).__name__}: {str(e)}")

    if debug_tf: C(f'==> strat_sha.sell_strat_sha() 474 leaving...')
    return mkt, pos, ta

#<=====>#
# Post Variables
#<=====>#
# (Any post-run variables can be defined here)

#<=====>#
# Default Run
#<=====>#
# (Default run code if this module is executed as a standalone script)
#<=====>#
