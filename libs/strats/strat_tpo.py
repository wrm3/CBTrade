# Python trading strategy: Two-Pole Oscillator
#<=====>#
# Description
#
# Two-Pole Oscillator Strategy
#
# This module implements the Two-Pole Oscillator trading strategy.
# It calculates a normalized price series based on the difference between the close
# and its moving average, and then applies a two-pole filter (double EMA smoothing)
# to derive an oscillator. A delayed version of the oscillator is also computed.
#
# A buy signal is generated when:
#   • The oscillator crosses over its delayed value (indicating upward momentum)
#   • The oscillator is below zero.
#
# A sell signal is generated when:
#   • The oscillator crosses under its delayed value (indicating downward momentum)
#   • The oscillator is above zero.
#
#<=====>#
# Known To Do List
#
# - Validate the oscillator calculations against the original PineScript implementation.
# - Fine-tune the SMA, oscillator lengths, and shift parameters as needed.
# - Integrate additional risk management features (e.g., stop-loss, trailing stops) if needed.
# - Confirm that all column names generated by ta_add_tpo match the expected inputs to the strategy.
#
#<=====>#
# Imports
#<=====>#
import sys
import numpy as np
import pandas as pd
import traceback
from libs.common import beep, dttm_get, narc
from libs.common import print_adv
from libs.strats._strat_common import disp_sell_tests, exit_if_logic

#<=====>#
# Variables
#<=====>#
lib_name = 'bot_strat_tpo'
log_name = 'bot_strat_tpo'

#<=====>#
# Functions
#<=====>#

# @safe_execute_silent()
@narc(1)
def settings_tpo(st):
    """
    Define and assign the settings for the Two-Pole Oscillator strategy.
    """
    sst = {
        "use_yn": "Y",
        "freqs": ["1d", "4h", "1h", "30min", "15min"],
        # Parameters for oscillator calculation:
        "sma_length": 25,      # period for the initial SMA calculation
        "osc_length": 20,      # period for the two-pole (double EMA) filter
        "shift": 4,            # number of bars to shift the oscillator to create a delayed value
        "disp_lvl": "N",       # display levels (used only for plotting in PineScript)
        "buy": {
            "prod_ids": [],
            "skip_prod_ids": [],
            "tests_min": {"***": 15, "15min": 13, "30min": 11, "1h": 9, "4h": 7, "1d": 5},
            "boost_tests_min": {"15min": 27, "30min": 23, "1h": 19, "4h": 15, "1d": 11},
            "max_open_poss_cnt_live": {
                "***": 2,
                "BTC-USDC": 5,
                "ETH-USDC": 5,
                "SOL-USDC": 5,
                "XRP-USDC": 3
            },
            "max_open_poss_cnt_test": {
                "***": 2,
                "BTC-USDC": 5,
                "ETH-USDC": 5,
                "SOL-USDC": 5,
                "XRP-USDC": 3
            },
            "show_tests_yn": "Y"
        },
        "sell": {
            "exit_if_profit_yn": "Y",
            "exit_if_profit_pct_min": 1,
            "exit_if_loss_yn": "N",
            "exit_if_loss_pct_max": 3,
            "show_tests_yn": "Y"
        }
    }
    st['strats']['tpo'] = sst
    return st

#<=====>#

# @safe_execute()
@narc(1)
def ta_add_tpo(df: pd.DataFrame, curr_prc, sma_length=25, osc_length=20, shift_val=4, tag=None) -> pd.DataFrame:
    """
    Calculate Two-Pole Oscillator values and add them to the DataFrame.
    
    Steps:
      1. Compute the SMA of the close price over sma_length periods.
      2. Compute the difference between close and its SMA.
      3. Normalize this difference by subtracting its own SMA and dividing by its standard deviation.
         This produces the normalized series 'sma_n1'.
      4. Apply a two-pole filter:
             - First, smooth the normalized series using an EMA with alpha = 2/(osc_length+1).
             - Then, smooth the result again using the same EMA to obtain the oscillator (two_p).
      5. Create a delayed oscillator value (two_pp) by shifting the oscillator by shift_val periods.
      6. Determine if the current market price is above or below the oscillator.
      7. Optionally, rename the oscillator columns using a tag.
    
    Returns:
        Modified DataFrame with new oscillator columns.
    """
    # Ensure the lengths do not exceed the DataFrame length.
    osc_length = min(osc_length, len(df))
    sma_length = min(sma_length, len(df))
    
    # 1. Compute the SMA of the close.
    df['sma'] = df['close'].rolling(window=sma_length, min_periods=1).mean()
    
    # 2. Compute the difference between close and its SMA.
    df['close_sma_diff'] = df['close'] - df['sma']
    
    # 3. Normalize the difference:
    df['sma_diff'] = df['close_sma_diff'].rolling(window=sma_length, min_periods=1).mean()
    df['std_diff'] = df['close_sma_diff'].rolling(window=sma_length, min_periods=1).std()
    df['sma_n1'] = (df['close_sma_diff'] - df['sma_diff']) / df['std_diff']
    
    # 4. Apply the two-pole filter (double EMA smoothing)
    alpha = 2.0 / (osc_length + 1)
    df['smooth1'] = df['sma_n1'].ewm(alpha=alpha, adjust=False).mean()
    df['two_p'] = df['smooth1'].ewm(alpha=alpha, adjust=False).mean()
    
    # 5. Create a delayed oscillator value.
    df['two_pp'] = df['two_p'].shift(shift_val)
    
    # 6. Determine if current price is above or below the oscillator.
    df['prc_abv_two_p'] = curr_prc > df['two_p']
    df['prc_bel_two_p'] = curr_prc < df['two_p']
    
    # 7. If a tag is provided, rename the oscillator columns.
    if tag:
        df[f'two_p{tag}'] = df['two_p']
        df[f'two_pp{tag}'] = df['two_pp']
        df[f'prc_abv_two_p{tag}'] = df['prc_abv_two_p']
        df[f'prc_bel_two_p{tag}'] = df['prc_bel_two_p']
        for c in ['two_p', 'two_pp', 'prc_abv_two_p', 'prc_bel_two_p']:
            df.pop(c)
    
    # Remove intermediate columns.
    for c in ['sma', 'close_sma_diff', 'sma_diff', 'std_diff', 'sma_n1', 'smooth1']:
        if c in df.columns:
            df.pop(c)
    
    return df

#<=====>#

# @safe_execute()
@narc(1)
def buy_strat_tpo(buy, ta, st_pair, curr_prc=None):
    """
    Two-Pole Oscillator Buy Strategy:
    
    - Calculates the Two-Pole Oscillator values.
    - Generates a buy signal when:
          • The oscillator crosses above its delayed version.
          • The oscillator value is below zero.
    
    Returns:
        Updated buy object and TA dictionary.
    """

    # Reset buy history.
    buy.buy_hist = []
    prod_id = buy.prod_id
    freq = buy.buy_strat_freq
    df = ta[freq].df

    # Get strategy parameters.
    sma_length = st_pair.strats.tpo.sma_length
    osc_length = st_pair.strats.tpo.osc_length
    shift_val  = st_pair.strats.tpo.shift

    # Set the current price from the close.
    df['curr_prc'] = df['close']
    if curr_prc:
        df['curr_prc'].iloc[-1] = curr_prc

    # Calculate Two-Pole Oscillator values; use a tag to rename columns.
    tag = '_osc'
    df = ta_add_tpo(df, curr_prc, sma_length=sma_length, osc_length=osc_length, shift_val=shift_val, tag=tag)

    # Determine column names (they will be tagged, e.g., 'two_p_osc' and 'two_pp_osc').
    osc_col = f'two_p{tag}'
    osc_delayed_col = f'two_pp{tag}'

    # Generate the buy signal:
    # A buy signal occurs when the oscillator crosses over its delayed value
    # and the oscillator value is below 0.
    df['tpo_buy_signal'] = (
        (df[osc_col] > df[osc_delayed_col]) &
        (df[osc_col].shift(1) <= df[osc_delayed_col].shift(1)) &
        (df[osc_col] < 0)
    )

    # Record buy signal history based on signal times.
    buy_hist = []
    if df['tpo_buy_signal'].any():
        signal_times = df[df['tpo_buy_signal']].index.tolist()
        for signal_time in signal_times:
            buy_hist.append(signal_time)

    # Set the current buy signal status.
    buy_now = df['tpo_buy_signal'].iloc[-1]
    if buy_now:
        buy.buy_yn = 'Y'
        buy.wait_yn = 'N'
        buy.buy_strat_type = 'up'
        buy.buy_strat_name = 'tpo'
        buy.buy_strat_freq = freq
    else:
        buy.buy_yn = 'N'
        buy.wait_yn = 'Y'
    buy.buy_hist = buy_hist

    # Update the TA dictionary with the modified DataFrame.
    ta[freq].df = df

    return buy, ta

#<=====>#

# @safe_execute()
@narc(1)
def sell_strat_tpo(mkt, pos, ta, st_pair, curr_prc=None):
    """
    Two-Pole Oscillator Sell Strategy:
    
    - Calculates the Two-Pole Oscillator values.
    - Generates a sell signal when:
          • The oscillator crosses under its delayed version.
          • The oscillator value is above 0.
    
    Returns:
        Updated market object, position object, and TA dictionary.
    """

    # Reset sell history.
    pos.sell_hist = []
    prod_id = pos.prod_id
    freq = pos.buy_strat_freq
    df = ta[freq].df

    # Get strategy parameters.
    sma_length = st_pair.strats.tpo.sma_length
    osc_length = st_pair.strats.tpo.osc_length
    shift_val  = st_pair.strats.tpo.shift

    # Set the current price.
    df['curr_prc'] = df['close']
    if curr_prc:
        df['curr_prc'].iloc[-1] = curr_prc

    # Calculate Two-Pole Oscillator values; use the same tag.
    tag = '_osc'
    df = ta_add_tpo(df, curr_prc, sma_length=sma_length, osc_length=osc_length, shift_val=shift_val, tag=tag)

    # Determine column names.
    osc_col = f'two_p{tag}'
    osc_delayed_col = f'two_pp{tag}'

    # Generate the sell signal:
    # A sell signal occurs when the oscillator crosses below its delayed value
    # and the oscillator value is above 0.
    df['tpo_sell_signal'] = (
        (df[osc_col] < df[osc_delayed_col]) &
        (df[osc_col].shift(1) >= df[osc_delayed_col].shift(1)) &
        (df[osc_col] > 0)
    )

    # Record sell signal history based on signal times.
    sell_hist = []
    if df['tpo_sell_signal'].any():
        signal_times = df[df['tpo_sell_signal']].index.tolist()
        for signal_time in signal_times:
            sell_hist.append(signal_time)

    # Set the current sell signal status.
    sell_now = df['tpo_sell_signal'].iloc[-1]
    if sell_now:
        pos.sell_yn = 'Y'
        pos.hodl_yn = 'N'
        pos.sell_strat_type = 'up'
        pos.sell_strat_name = 'tpo'
        pos.sell_strat_freq = freq
        pos = exit_if_logic(pos=pos, st_pair=st_pair)
    else:
        pos.sell_yn = 'N'
        pos.hodl_yn = 'Y'
    pos.sell_hist = sell_hist

    # Update the TA dictionary with the modified DataFrame.
    ta[freq].df = df

    return mkt, pos, ta

#<=====>#
# Post Variables
#<=====>#
# (Any post-run variables can be defined here)

#<=====>#
# Default Run
#<=====>#
# (Default run code if this module is executed as a standalone script)
#<=====>#
