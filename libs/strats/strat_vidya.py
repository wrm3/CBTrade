# Python trading strategy: Volumatic Variable Index Dynamic Average (VIDYA)
#<=====>#
# Description
#
# Volumatic VIDYA Strategy
#
# This module implements the Volumatic Variable Index Dynamic Average (VIDYA)
# strategy. It computes a dynamic average based on a momentum‐adjusted recursive
# filter (the VIDYA) and then derives upper and lower bands using ATR and a
# distance factor.
#
# With this update the module now produces two buy signals and two sell signals:
#   • Buy Signal Event ("green ball"): occurs when a trend cross upward happens.
#   • Buy Signal State ("line is green"): is true continuously when the VIDYA line is green.
#   • Sell Signal Event ("purple ball"): occurs when a trend cross downward happens.
#   • Sell Signal State ("line is red"): is true continuously when the VIDYA line is red.
#
# For the current overall decision we use the continuous state (line color),
# but we also record the events in history.
#
#<=====>#
# Known To Do List
#
# - Validate the VIDYA calculation against the original PineScript implementation.
# - Fine-tune the VIDYA parameters (length, momentum, band distance) as needed.
# - Integrate additional risk management features (e.g., stop-loss, trailing stops) if needed.
# - Confirm that all column names generated by ta_add_vidya match the expected inputs to the strategy.
#
#<=====>#
# Imports
#<=====>#
import sys
import numpy as np
import pandas as pd
import math
import traceback
from libs.common import beep, dttm_get, narc
from libs.common import print_adv
from libs.strats._strat_common import disp_sell_tests, exit_if_logic

#<=====>#
# Variables
#<=====>#
lib_name = 'bot_strat_vidya'
log_name = 'bot_strat_vidya'

#<=====>#
# Settings Function
#<=====>#
# @safe_execute_silent()
@narc(1)
def settings_vidya(st):
    """
    Define and assign the settings for the Volumatic VIDYA strategy.
    """
    sst = {
        "use_yn": "Y",
        "freqs": ["1d", "4h", "1h", "30min", "15min"],
        "source": "close",
        "vidya_length": 10,
        "vidya_momentum": 20,
        "band_distance": 2.0,
        "pivot_left_bars": 3,
        "pivot_right_bars": 3,
        "shadow": "Y",
        "up_trend_color": "green",   # Color for uptrend
        "down_trend_color": "red",   # Color for downtrend
        "buy": {
            "prod_ids": [],
            "skip_prod_ids": [],
            "tests_min": {"***": 15, "15min": 13, "30min": 11, "1h": 9, "4h": 7, "1d": 5},
            "boost_tests_min": {"15min": 27, "30min": 23, "1h": 19, "4h": 15, "1d": 11},
            "max_open_poss_cnt_live": {
                "***": 2,
                "BTC-USDC": 5,
                "ETH-USDC": 5,
                "SOL-USDC": 5,
                "XRP-USDC": 3
            },
            "max_open_poss_cnt_test": {
                "***": 2,
                "BTC-USDC": 5,
                "ETH-USDC": 5,
                "SOL-USDC": 5,
                "XRP-USDC": 3
            },
            "show_tests_yn": "Y"
        },
        "sell": {
            "exit_if_profit_yn": "Y",
            "exit_if_profit_pct_min": 1,
            "exit_if_loss_yn": "N",
            "exit_if_loss_pct_max": 3,
            "show_tests_yn": "Y"
        }
    }
    st['strats']['vidya'] = sst
    return st

#<=====>#
# Helper: ATR Calculation
#<=====>#
# @safe_execute()
@narc(1)
def compute_atr(df: pd.DataFrame, period: int = 200) -> pd.Series:
    """
    Compute the Average True Range (ATR) over a specified period.
    """
    high = df['high']
    low = df['low']
    close = df['close']
    tr1 = high - low
    tr2 = (high - close.shift(1)).abs()
    tr3 = (low - close.shift(1)).abs()
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    atr = tr.rolling(window=period, min_periods=1).mean()
    return atr

#<=====>#
# Technical Analysis Function: Compute VIDYA and Related Values
#<=====>#
# @safe_execute()
@narc(1)
def ta_add_vidya(
    df: pd.DataFrame,
    prc_mkt,
    vidya_length: int = 10,
    vidya_momentum: int = 20,
    band_distance: float = 2.0,
    pivot_left_bars: int = 3,
    pivot_right_bars: int = 3,
    source: str = 'close',
    up_trend_color: str = "green",
    down_trend_color: str = "red",
    shadow: bool = True,
    tag: str = None
) -> pd.DataFrame:
    """
    Calculate the Volumatic VIDYA and related bands, trend and volume statistics.
    
    Steps:
      1. Compute the ATR (period=200).
      2. Calculate the momentum of the source (change in price).
      3. For a rolling window of vidya_momentum, compute the sum of positive and negative momentum.
      4. Derive the absolute Chande Momentum Oscillator (abs_cmo).
      5. Compute a recursive VIDYA value using a momentum-adjusted smoothing factor.
      6. Smooth the VIDYA by applying a simple moving average (window=15).
      7. Derive upper and lower bands using the ATR and a distance factor.
      8. Iteratively determine the trend:
             - A crossover (price crossing above the upper band) sets the trend upward.
             - A crossunder (price crossing below the lower band) sets the trend downward.
      9. Mark trend-change events (cross-up and cross-down).
     10. Define a 'smoothed_value' that equals the lower band when trending up and the upper band when trending down,
         except on bars where the trend changes (set to NaN).
     11. Accumulate volume during trends and calculate a delta volume percentage.
     12. Optionally, rename the computed columns with a tag.
    
    Returns:
        The modified DataFrame with new VIDYA-related columns.
    """
    n = len(df)
    # 1. Compute ATR (using a 200-bar period)
    df['atr'] = compute_atr(df, period=100)
    
    # 2. Calculate momentum (price change) from the source
    df['momentum'] = df[source].diff()
    
    # 3. Compute positive and negative momentum over the vidya_momentum period
    df['pos_mom'] = df['momentum'].apply(lambda x: x if x >= 0 else 0)
    df['neg_mom'] = df['momentum'].apply(lambda x: -x if x < 0 else 0)
    df['sum_pos_mom'] = df['pos_mom'].rolling(window=vidya_momentum, min_periods=1).sum()
    df['sum_neg_mom'] = df['neg_mom'].rolling(window=vidya_momentum, min_periods=1).sum()
    
    # 4. Calculate absolute CMO (avoid division by zero)
    df['denom'] = df['sum_pos_mom'] + df['sum_neg_mom']
    df['abs_cmo'] = (100 * (df['sum_pos_mom'] - df['sum_neg_mom']) / df['denom']).abs()
    df['abs_cmo'] = df['abs_cmo'].replace([np.inf, -np.inf], 0).fillna(0).infer_objects(copy=False)
    
    # 5. Recursive VIDYA calculation
    alpha = 2.0 / (vidya_length + 1)
    src_vals = df[source].values
    abs_cmo_vals = df['abs_cmo'].values
    vidya_vals = np.zeros(n)
    vidya_vals[0] = src_vals[0]
    for i in range(1, n):
        factor = alpha * (abs_cmo_vals[i] / 100.0)
        vidya_vals[i] = factor * src_vals[i] + (1 - factor) * vidya_vals[i-1]
    df['vidya_raw'] = vidya_vals
    
    # 6. Smooth the VIDYA with a simple moving average (window=15)
    # df['vidya'] = pd.Series(vidya_vals).rolling(window=15, min_periods=1).mean()
    df['vidya'] = pd.Series(vidya_vals, index=df.index).rolling(window=15, min_periods=1).mean()


    # 7. Compute upper and lower bands using ATR and the band distance factor
    df['upper_band'] = df['vidya'] + df['atr'] * band_distance
    df['lower_band'] = df['vidya'] - df['atr'] * band_distance
    
    # 8. Determine trend direction iteratively
    is_trend_up = np.zeros(n, dtype=bool)
    is_trend_up[0] = False  # initial assumption
    for i in range(1, n):
        # Crossover: source crosses above upper_band → trend becomes up
        if (src_vals[i] > df['upper_band'].iloc[i]) and (src_vals[i-1] <= df['upper_band'].iloc[i-1]):
            is_trend_up[i] = True
        # Crossunder: source crosses below lower_band → trend becomes down
        elif (src_vals[i] < df['lower_band'].iloc[i]) and (src_vals[i-1] >= df['lower_band'].iloc[i-1]):
            is_trend_up[i] = False
        else:
            is_trend_up[i] = is_trend_up[i-1]
    df['is_trend_up'] = is_trend_up
    # For convenience, define the downtrend state as the inverse.
    df['is_trend_down'] = ~df['is_trend_up']
    
    # 9. Identify trend change events
    trend_cross_up = np.zeros(n, dtype=bool)
    trend_cross_down = np.zeros(n, dtype=bool)
    trend_cross_up[0] = False
    trend_cross_down[0] = False
    for i in range(1, n):
        trend_cross_up[i] = is_trend_up[i] and not is_trend_up[i-1]
        trend_cross_down[i] = (not is_trend_up[i]) and is_trend_up[i-1]
    df['trend_cross_up'] = trend_cross_up
    df['trend_cross_down'] = trend_cross_down
    
    # 10. Define smoothed_value: use lower_band when trending up, upper_band when trending down,
    #     but set to NaN on a trend-change bar.
    smoothed_value = np.empty(n)
    smoothed_value[0] = df['upper_band'].iloc[0] if not is_trend_up[0] else df['lower_band'].iloc[0]
    for i in range(1, n):
        if trend_cross_up[i] or trend_cross_down[i]:
            smoothed_value[i] = np.nan
        else:
            smoothed_value[i] = df['lower_band'].iloc[i] if is_trend_up[i] else df['upper_band'].iloc[i]
    df['smoothed_value'] = smoothed_value
    
    # 11. Accumulate volume during trends and compute delta volume percentage
    up_trend_vol = np.zeros(n)
    down_trend_vol = np.zeros(n)
    up_trend_vol[0] = 0
    down_trend_vol[0] = 0
    for i in range(1, n):
        if trend_cross_up[i] or trend_cross_down[i]:
            up_trend_vol[i] = 0
            down_trend_vol[i] = 0
        else:
            up_trend_vol[i] = up_trend_vol[i-1] + (df['volume'].iloc[i] if df['close'].iloc[i] > df['open'].iloc[i] else 0)
            down_trend_vol[i] = down_trend_vol[i-1] + (df['volume'].iloc[i] if df['close'].iloc[i] < df['open'].iloc[i] else 0)
    avg_volume_delta = (up_trend_vol + down_trend_vol) / 2.0
    delta_volume_percentage = np.divide(
        up_trend_vol - down_trend_vol,
        avg_volume_delta,
        out=np.zeros_like(up_trend_vol, dtype=float),
        where=(avg_volume_delta != 0)
    ) * 100
    df['up_trend_volume'] = up_trend_vol
    df['down_trend_volume'] = down_trend_vol
    df['avg_volume_delta'] = avg_volume_delta
    df['delta_volume_pct'] = delta_volume_percentage
    
    # 12. Clean up intermediate columns
    for col in ['momentum', 'pos_mom', 'neg_mom', 'sum_pos_mom', 'sum_neg_mom', 'denom', 'abs_cmo', 'vidya_raw', 'atr']:
        if col in df.columns:
            df.drop(columns=col, inplace=True)


    # for col in ['vidya', 'upper_band', 'lower_band', 'smoothed_value', 'is_trend_up', 'trend_cross_up', 'trend_cross_down', 'delta_volume_pct']:
    #     print(f"{col}: {df[col].iloc[-1]}")

    # 13. If a tag is provided, rename the computed columns accordingly.
    if tag:
        df[f'vidya{tag}'] = df['vidya']
        df[f'upper_band{tag}'] = df['upper_band']
        df[f'lower_band{tag}'] = df['lower_band']
        df[f'smoothed_value{tag}'] = df['smoothed_value']
        df[f'is_trend_up{tag}'] = df['is_trend_up']
        df[f'is_trend_down{tag}'] = df['is_trend_down']
        df[f'trend_cross_up{tag}'] = df['trend_cross_up']
        df[f'trend_cross_down{tag}'] = df['trend_cross_down']
        df[f'delta_volume_pct{tag}'] = df['delta_volume_pct']
        # Remove the original columns to avoid duplication
        for col in ['vidya', 'upper_band', 'lower_band', 'smoothed_value', 'is_trend_up', 'trend_cross_up', 'trend_cross_down', 'delta_volume_pct']:
            df.drop(columns=col, inplace=True)
    
    # 14. Mark whether the current market price is above or below the smoothed VIDYA value
    # (Useful for additional signal confirmation.)
    if 'smoothed_value' in df.columns:
        df[f'prc_abv{tag}'] = prc_mkt > df['smoothed_value']
        df[f'prc_bel{tag}'] = prc_mkt < df['smoothed_value']
    
    return df

#<=====>#
# Buy Strategy Function
#<=====>#
# @safe_execute()
@narc(1)
def buy_strat_vidya(buy, ta, st_pair, curr_prc=None):
    """
    VIDYA Buy Strategy:
    
    - Calculates the VIDYA and its related trend-change signals.
    - Creates two buy indicators:
          • vidya_buy_signal_event ("green ball"): True only on bars where a trend cross up occurs.
          • vidya_buy_signal_state ("line is green"): True on every bar while the VIDYA is in an uptrend.
    - For the current overall decision, we use the continuous state (line is green).
    - The event signals (which occur only at the moment of transition) are recorded in history.
    
    Returns:
        Updated buy object and TA dictionary.
    """

    # Reset buy history.
    buy.buy_hist = []         # overall history (if needed)
    buy.buy_hist_event = []   # history of event signals only
    prod_id = buy.prod_id
    freq = buy.buy_strat_freq
    df = ta[freq].df

    # Retrieve strategy parameters.
    source           = st_pair.strats.vidya.source
    vidya_length     = st_pair.strats.vidya.vidya_length
    vidya_momentum   = st_pair.strats.vidya.vidya_momentum
    band_distance    = st_pair.strats.vidya.band_distance
    pivot_left_bars  = st_pair.strats.vidya.pivot_left_bars
    pivot_right_bars = st_pair.strats.vidya.pivot_right_bars
    shadow           = True if st_pair.strats.vidya.shadow == "Y" else False
    up_trend_color   = st_pair.strats.vidya.up_trend_color
    down_trend_color = st_pair.strats.vidya.down_trend_color

    # Set the current price from the source. Ensure pure numpy dtypes to avoid extension blocks.
    df = df.copy()
    if source in df.columns:
        df['curr_prc'] = pd.to_numeric(df[source], errors='coerce').astype('float64')
    else:
        df['curr_prc'] = pd.Series(index=df.index, dtype='float64')
    if curr_prc is not None and len(df) > 0:
        df.loc[df.index[-1], 'curr_prc'] = float(curr_prc)

    # Calculate the VIDYA and related columns (using a tag for renaming).
    tag = '_vidya'
    df = ta_add_vidya(
        df, curr_prc,
        vidya_length=vidya_length,
        vidya_momentum=vidya_momentum,
        band_distance=band_distance,
        pivot_left_bars=pivot_left_bars,
        pivot_right_bars=pivot_right_bars,
        source=source,
        up_trend_color=up_trend_color,
        down_trend_color=down_trend_color,
        shadow=shadow,
        tag=tag
    )

    # Create two separate buy signals:
    # Buy Signal Event ("green ball"): only on the bar where a trend cross up occurs.
    df[f'trend_cross_up{tag}'] = df[f'trend_cross_up{tag}'].astype('int8') if f'trend_cross_up{tag}' in df.columns else 0
    df[f'is_trend_up{tag}'] = df[f'is_trend_up{tag}'].astype('int8') if f'is_trend_up{tag}' in df.columns else 0
    df['vidya_buy_signal_event'] = df[f'trend_cross_up{tag}']
    # Buy Signal State ("line is green"): continuous signal when the VIDYA line is in an uptrend.
    df['vidya_buy_signal_state'] = df[f'is_trend_up{tag}']

    # For the overall current decision we use the state signal.
    # df['vidya_buy_signal'] = df['vidya_buy_signal_state']
    df['vidya_buy_signal'] = df['vidya_buy_signal_event']

    # Record event signal history (only the bars where the event occurred).
    buy.buy_hist_event = df.index[df['vidya_buy_signal_event']].tolist()

    # Optionally, you may also record the continuous state history:
    # buy.buy_hist_state = df.index[df['vidya_buy_signal_state']].tolist()

    # Use the current (last bar) state as the decision.
    # buy_now = df['vidya_buy_signal_state'].iloc[-1]
    buy_now = df['vidya_buy_signal_event'].iloc[-1]
    if buy_now:
        buy.buy_yn = 'Y'
        buy.wait_yn = 'N'
        buy.buy_strat_type = 'up'
        buy.buy_strat_name = 'vidya'
        buy.buy_strat_freq = freq
    else:
        buy.buy_yn = 'N'
        buy.wait_yn = 'Y'
    # Also record overall history if desired.
    # buy.buy_hist = list(set(buy.buy_hist_event + buy.buy_hist_state))
    buy.buy_hist = list(set(buy.buy_hist_event))

    # Update the TA dictionary with the modified DataFrame.
    ta[freq].df = df

    return buy, ta

#<=====>#
# Sell Strategy Function
#<=====>#
# @safe_execute()
@narc(1)
def sell_strat_vidya(mkt, pos, ta, st_pair, curr_prc=None):
    """
    VIDYA Sell Strategy:
    
    - Calculates the VIDYA and its related trend-change signals.
    - Creates two sell indicators:
          • vidya_sell_signal_event ("purple ball"): True only on bars where a trend cross down occurs.
          • vidya_sell_signal_state ("line is red"): True on every bar while the VIDYA is in a downtrend.
    - For the current overall decision we use the continuous state (line is red).
    - The event signals (which occur only at the moment of transition) are recorded in history.
    
    Returns:
        Updated market object, position object, and TA dictionary.
    """

    # Reset sell history.
    pos.sell_hist = []           # overall history
    pos.sell_hist_event = []     # event signal history
    prod_id = pos.prod_id
    freq = pos.buy_strat_freq
    df = ta[freq].df

    # Retrieve strategy parameters.
    source           = st_pair.strats.vidya.source
    vidya_length     = st_pair.strats.vidya.vidya_length
    vidya_momentum   = st_pair.strats.vidya.vidya_momentum
    band_distance    = st_pair.strats.vidya.band_distance
    pivot_left_bars  = st_pair.strats.vidya.pivot_left_bars
    pivot_right_bars = st_pair.strats.vidya.pivot_right_bars
    shadow           = True if st_pair.strats.vidya.shadow == "Y" else False
    up_trend_color   = st_pair.strats.vidya.up_trend_color
    down_trend_color = st_pair.strats.vidya.down_trend_color

    # Set the current price.
    df['curr_prc'] = df[source]
    if curr_prc:
        df['curr_prc'].iloc[-1] = curr_prc

    # Calculate the VIDYA and related columns (using the same tag).
    tag = '_vidya'
    df = ta_add_vidya(
        df, curr_prc,
        vidya_length=vidya_length,
        vidya_momentum=vidya_momentum,
        band_distance=band_distance,
        pivot_left_bars=pivot_left_bars,
        pivot_right_bars=pivot_right_bars,
        source=source,
        up_trend_color=up_trend_color,
        down_trend_color=down_trend_color,
        shadow=shadow,
        tag=tag
    )

    # Create two separate sell signals:
    # Sell Signal Event ("purple ball"): only on the bar where a trend cross down occurs.
    df['vidya_sell_signal_event'] = df[f'trend_cross_down{tag}']
    # Sell Signal State ("line is red"): continuous signal when the VIDYA line is in a downtrend.
    df['vidya_sell_signal_state'] = df[f'is_trend_down{tag}']

    # For the overall decision we use the state signal.
    # df['vidya_sell_signal'] = df['vidya_sell_signal_state']
    df['vidya_sell_signal'] = df['vidya_sell_signal_event']

    # Record event signal history.
    pos.sell_hist_event = df.index[df['vidya_sell_signal_event']].tolist()

    # Optionally, record the continuous state history.
    # pos.sell_hist_state = df.index[df['vidya_sell_signal_state']].tolist()

    # Use the current (last bar) state as the decision.
    # sell_now = df['vidya_sell_signal_state'].iloc[-1]
    sell_now = df['vidya_sell_signal_event'].iloc[-1]
    if sell_now:
        pos.sell_yn = 'Y'
        pos.hodl_yn = 'N'
        pos.sell_strat_type = 'up'
        pos.sell_strat_name = 'vidya'
        pos.sell_strat_freq = freq
        pos = exit_if_logic(pos=pos, st_pair=st_pair)
    else:
        pos.sell_yn = 'N'
        pos.hodl_yn = 'Y'
    # Also record overall sell history if desired.
    # pos.sell_hist = list(set(pos.sell_hist_event + pos.sell_hist_state))
    pos.sell_hist = list(set(pos.sell_hist_event))

    # Update the TA dictionary with the modified DataFrame.
    ta[freq].df = df

    return mkt, pos, ta

#<=====>#
# Post Variables
#<=====>#
# (Any post-run variables can be defined here)

#<=====>#
# Default Run
#<=====>#
# (Default run code if this module is executed as a standalone script)

#<=====>#


# Original Pine Script Code
'''
// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International  
// https://creativecommons.org/licenses/by-nc-sa/4.0/
// © BigBeluga

//@version=6
indicator('Volumatic Variable Index Dynamic Average [BigBeluga]', 'Volumatic VIDYA [BigBeluga]', overlay = true, max_lines_count = 500, max_labels_count = 500)


// ＩＮＰＵＴＳ ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{
// Input parameters for length, momentum, and source data
int vidya_length = input.int(10, 'VIDYA Length') // Length of the VIDYA calculation
int vidya_momentum = input.int(20, 'VIDYA Momentum') // Momentum length for VIDYA
float band_distance = input.float(2, 'Distance factor for upper/lower bands', step = 0.1) // Distance factor for upper/lower bands
// Define pivot parameters
int pivot_left_bars = 3 // Left side pivot bars
int pivot_right_bars = pivot_left_bars // Right side pivot bars

float source = input.source(close, 'Source') // Source for VIDYA calculation

// Define colors for up and down trends
color up_trend_color = input(#17dfad, '+', group = 'Color', inline = 'c') // Color for uptrend
color down_trend_color = input(#dd326b, '-', group = 'Color', inline = 'c') // Color for downtrend
bool shadow = input.bool(true, 'Shadow', group = 'Color', inline = 'c')

// Initialize variables for line, volume, and trend state
var line pivot_line = na // Variable for storing line references
var float volume_value = na // Variable for storing volume data
float smoothed_value = na // Smoothing variable for VIDYA trend levels
var bool is_trend_up = false // Boolean variable for tracking trend direction

// Initialize arrays for storing line and volume information
var array<line> liquidity_lines_low = array.new<line>(500) // Array for storing lines for lows
var array<line> liquidity_lines_high = array.new<line>(500) // Array for storing lines for highs

var float up_trend_volume = na // Volume accumulated during uptrend
var float down_trend_volume = na // Volume accumulated during downtrend
// }


// ＦＵＮＣＴＩＯＮＳ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{

// Define VIDYA (Variable Index Dynamic Average) function
vidya_calc(src, vidya_length, vidya_momentum) =>
    float momentum = ta.change(src)
    float sum_pos_momentum = math.sum(momentum >= 0 ? momentum : 0.0, vidya_momentum)
    float sum_neg_momentum = math.sum(momentum >= 0 ? 0.0 : -momentum, vidya_momentum)
    float abs_cmo = math.abs(100 * (sum_pos_momentum - sum_neg_momentum) / (sum_pos_momentum + sum_neg_momentum))
    float alpha = 2 / (vidya_length + 1)
    var float vidya_value = 0.0
    vidya_value := alpha * abs_cmo / 100 * src + (1 - alpha * abs_cmo / 100) * nz(vidya_value[1])

    ta.sma(vidya_value, 15)

// Method to extend lines and add labels for liquidity levels
method extend_liquidity_lines(array<line> line_array, float price_level, bool is_cross, volume_val) =>
    if line_array.size() > 0 and last_bar_index - bar_index < 5000
        for i = 0 to line_array.size() - 1 by 1
            if i < line_array.size()
                line liquidity_line = line_array.get(i)
                float current_line_level = line.get_y2(liquidity_line)
                bool price_cross = is_cross ? price_level < current_line_level and price_level[1] >= current_line_level : price_level > current_line_level and price_level[1] <= current_line_level

                bool is_short_line = bar_index - line.get_x1(liquidity_line) < 50

                if price_cross and is_short_line
                    line.set_x2(liquidity_line, bar_index)
                    line_array.remove(i)

                    // Add volume label to the liquidity zone
                    label.new(bar_index - 1, price_level[1], str.tostring(volume_val, format.volume), color = color.rgb(0, 0, 0, 99), style = is_cross ? label.style_label_lower_left : label.style_label_upper_left, textcolor = chart.fg_color, size = size.small)

                    // Add a circle label to represent liquidity zone
                    label.new(bar_index - 1, price_level[1], text = '◉', color = #00000003, textcolor = is_cross ? down_trend_color : up_trend_color, style = label.style_label_center, size = size.normal)
                    // }


// ＣＡＬＣＵＬＡＴＩＯＮＳ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{
// Calculate the Average True Range (ATR)
float atr_value = ta.atr(200) // ATR calculation with length of 200

// Calculate the VIDYA (Variable Index Dynamic Average)
vidya_value = vidya_calc(source, vidya_length, vidya_momentum)

// Calculate upper and lower bands based on VIDYA and ATR
float upper_band = vidya_value + atr_value * band_distance
float lower_band = vidya_value - atr_value * band_distance

// Detect trend direction using crossovers of source with bands
if ta.crossover(source, upper_band)
    is_trend_up := true
    is_trend_up
if ta.crossunder(source, lower_band)
    is_trend_up := false
    is_trend_up

// Set trend-based smoothing variable
if is_trend_up
    smoothed_value := lower_band
    smoothed_value
if not is_trend_up
    smoothed_value := upper_band
    smoothed_value
if ta.change(is_trend_up)
    smoothed_value := na
    smoothed_value

// Calculate pivot highs and lows for price action
bool pivot_high = not na(ta.pivothigh(pivot_left_bars, pivot_right_bars))
bool pivot_low = not na(ta.pivotlow(close, pivot_left_bars, pivot_right_bars))

// Create and store lines for pivot lows (support zones)
if low[pivot_right_bars] > smoothed_value and pivot_low
    pivot_line := line.new(bar_index[pivot_right_bars], low[pivot_right_bars], bar_index[pivot_right_bars] + 5, low[pivot_right_bars], color = color.new(up_trend_color, 50))

    liquidity_lines_low.push(pivot_line)
    volume_value := math.sum(volume, pivot_right_bars + pivot_left_bars) / (pivot_right_bars + pivot_left_bars)
    volume_value

// Create and store lines for pivot highs (resistance zones)
if high[pivot_right_bars] < smoothed_value and pivot_high
    pivot_line := line.new(bar_index[pivot_right_bars], high[pivot_right_bars], bar_index[pivot_right_bars] + 5, high[pivot_right_bars], color = color.new(down_trend_color, 50))

    liquidity_lines_high.push(pivot_line)
    volume_value := math.sum(-volume, pivot_right_bars + pivot_left_bars) / (pivot_right_bars + pivot_left_bars)
    volume_value

// Extend lines to track price movements
liquidity_lines_high.extend_liquidity_lines(smoothed_value, true, volume_value)
liquidity_lines_low.extend_liquidity_lines(smoothed_value, false, volume_value)

// Detect changes in the trend direction
bool trend_cross_up = not is_trend_up[1] and is_trend_up
bool trend_cross_down = not is_trend_up and is_trend_up[1]

// Reset volume counters when trend changes
if ta.change(trend_cross_up) or ta.change(trend_cross_down)
    up_trend_volume := 0
    down_trend_volume := 0
    down_trend_volume

// Accumulate volume during trends
if not(ta.change(trend_cross_up) or ta.change(trend_cross_down))
    up_trend_volume := up_trend_volume + (close > open ? volume : 0)
    down_trend_volume := down_trend_volume + (close < open ? volume : 0)
    down_trend_volume

// Calculate average volume
float avg_volume_delta = (up_trend_volume + down_trend_volume) / 2

// Determine the color of the trend
color trend_color = is_trend_up ? up_trend_color : not is_trend_up ? down_trend_color : chart.fg_color

// Calculate delta volume percentage
string delta_volume = str.tostring((up_trend_volume - down_trend_volume) / avg_volume_delta * 100, format.percent) == 'NaN%' ? '0%' : str.tostring((up_trend_volume - down_trend_volume) / avg_volume_delta * 100, format.percent)

// }


// ＰＬＯＴ ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{
// Display labels for volume and trend statistics on the last bar
if barstate.islast
    label.delete(label.new(bar_index, smoothed_value, 'Buy: ' + str.tostring(up_trend_volume, format.volume) + '\n Sell: ' + str.tostring(down_trend_volume, format.volume) + '\nDelta Volume: ' + delta_volume, color = color.new(trend_color, 90), style = is_trend_up ? label.style_label_upper_left : label.style_label_lower_left, textcolor = chart.fg_color)[1])

    label.delete(label.new(bar_index, smoothed_value, text = '✪', color = #00000003, textcolor = trend_color, style = label.style_label_center, size = size.large)[1])

// Plot the VIDYA trend line
p1 = plot(smoothed_value, color = trend_color, linewidth = 2, style = plot.style_linebr)
p2 = plot(hl2, display = display.none)

// Fill between the plot and the VIDYA line
fill(p1, p2, smoothed_value, hl2, color.new(trend_color, shadow ? 80 : 100), na)

// Plot trend change markers (up and down arrows)
plotshape(series = trend_cross_up[1] ? smoothed_value[0] : na, title = 'Trend Up', style = shape.labelup, location = location.absolute, color = color.new(up_trend_color, 50), text = '▲', textcolor = chart.fg_color)

plotshape(series = trend_cross_down[1] ? smoothed_value[0] : na, title = 'Trend Down', style = shape.labeldown, location = location.absolute, color = color.new(down_trend_color, 50), text = '▼', textcolor = chart.fg_color)
// }
'''